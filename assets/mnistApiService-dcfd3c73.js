class d{baseUrl;isConnected=!1;constructor(){this.baseUrl={}.VITE_API_URL||"http://localhost:5000"}async checkConnection(){try{const e=await fetch(`${this.baseUrl}/health`,{method:"GET",headers:{"Content-Type":"application/json"}});if(e.ok){const t=await e.json();return this.isConnected=t.status==="healthy",console.log("API Health:",t),this.isConnected}return this.isConnected=!1,!1}catch(e){return console.warn("API not available:",e),this.isConnected=!1,!1}}async healthCheck(){return this.checkConnection()}async forwardPass(e,t,r,s,n){if(!this.isConnected)throw new Error("API not connected");const a=await(await fetch(`${this.baseUrl}/forward`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({weights:e,biases:t,features:r,similarity_metric:s,activation_function:n})})).json();if(!a.success)throw new Error(a.error||"Forward pass failed");return a.result}async computeGradients(e,t,r,s,n,o){if(!this.isConnected)throw new Error("API not connected");const i=await(await fetch(`${this.baseUrl}/gradients`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({weights:e,biases:t,batch_features:r,batch_labels:s,similarity_metric:n,activation_function:o})})).json();if(!i.success)throw new Error(i.error||"Gradient computation failed");return i.result}async trainStep(e,t,r,s,n,o,a=.01){if(!this.isConnected)throw new Error("API not connected");const c=await(await fetch(`${this.baseUrl}/train_step`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({weights:e,biases:t,batch_features:r,batch_labels:s,similarity_metric:n,activation_function:o,learning_rate:a})})).json();if(!c.success)throw new Error(c.error||"Training step failed");return c.result}async computeAccuracy(e,t,r,s,n,o){if(!this.isConnected)throw new Error("API not connected");const i=await(await fetch(`${this.baseUrl}/accuracy`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({weights:e,biases:t,test_features:r,test_labels:s,similarity_metric:n,activation_function:o})})).json();if(!i.success)throw new Error(i.error||"Accuracy computation failed");return i.accuracy}async batchForward(e,t,r,s,n){if(!this.isConnected)throw new Error("API not connected");const a=await(await fetch(`${this.baseUrl}/batch_forward`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({weights:e,biases:t,batch_features:r,similarity_metric:s,activation_function:n})})).json();if(!a.success)throw new Error(a.error||"Batch forward pass failed");return a.results}async getAvailableDatasets(){if(!this.isConnected)throw new Error("API not connected");const t=await(await fetch(`${this.baseUrl}/datasets/available`,{method:"GET",headers:{"Content-Type":"application/json"}})).json();if(!t.success)throw new Error(t.error||"Failed to get available datasets");return t.datasets}async loadDataset(e="mnist",t="train",r){if(!this.isConnected)throw new Error("API not connected");const s={dataset_name:e,subset:t};r!==void 0&&(s.max_samples=r);const o=await(await fetch(`${this.baseUrl}/datasets/load`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(s)})).json();if(!o.success)throw new Error(o.error||"Failed to load dataset");return o.dataset_info}async getDatasetSample(e="mnist",t="train",r=0,s=100){if(!this.isConnected)throw new Error("API not connected");const o=await(await fetch(`${this.baseUrl}/datasets/sample`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({dataset_name:e,subset:t,start_idx:r,count:s})})).json();if(!o.success)throw new Error(o.error||"Failed to get dataset sample");return o.data}async getTrainingBatch(e="mnist",t="train",r=32,s){if(!this.isConnected)throw new Error("API not connected");const n={dataset_name:e,subset:t,batch_size:r};s!==void 0&&(n.class_filter=s);const a=await(await fetch(`${this.baseUrl}/datasets/batch`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(n)})).json();if(!a.success)throw new Error(a.error||"Failed to get training batch");return a.batch}async preprocessImage(e,t=!0){if(!this.isConnected)throw new Error("API not connected");const s=await(await fetch(`${this.baseUrl}/datasets/preprocess`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({image:e,normalize:t})})).json();if(!s.success)throw new Error(s.error||"Failed to preprocess image");return s}extractNetworkParams(e){return{weights:e.map(t=>t.weights),biases:e.map(t=>t.bias)}}extractBatchData(e){return{features:e.map(t=>t.features),labels:e.map(t=>t.label)}}get connected(){return this.isConnected}get apiUrl(){return this.baseUrl}setBaseUrl(e){this.baseUrl=e,this.isConnected=!1}async getModelWeights(){if(!this.isConnected)throw new Error("API not connected");const t=await(await fetch(`${this.baseUrl}/model/weights`,{method:"GET",headers:{"Content-Type":"application/json"}})).json();if(!t.success)throw new Error(t.error||"Failed to get model weights");return t.result}async getModelActivations(e,t,r,s,n){if(!this.isConnected)throw new Error("API not connected");const a=await(await fetch(`${this.baseUrl}/model/activations`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({features:e,weights:t,biases:r,similarity_metric:s,activation_function:n})})).json();if(!a.success)throw new Error(a.error||"Failed to get model activations");return a.result}async getWeightVisualization(e,t="diverging"){if(!this.isConnected)throw new Error("API not connected");const r=new URLSearchParams;e!==void 0&&r.append("class_id",e.toString()),r.append("colormap",t);const n=await(await fetch(`${this.baseUrl}/model/weights/visualization?${r}`,{method:"GET",headers:{"Content-Type":"application/json"}})).json();if(!n.success)throw new Error(n.error||"Failed to get weight visualization");return n.result}async updateModelWeights(e,t){if(!this.isConnected)throw new Error("API not connected");const s=await(await fetch(`${this.baseUrl}/model/weights`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({weights:e,biases:t})})).json();if(!s.success)throw new Error(s.error||"Failed to update model weights");return s.result}async getTrainingMetrics(){if(!this.isConnected)throw new Error("API not connected");const t=await(await fetch(`${this.baseUrl}/training/metrics`,{method:"GET",headers:{"Content-Type":"application/json"}})).json();if(!t.success)throw new Error(t.error||"Failed to get training metrics");return t.result}async initializeTernaryModel(e=10,t=784,r=.7){if(!this.isConnected)throw new Error("API not connected");const n=await(await fetch(`${this.baseUrl}/model/initialize_ternary`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({num_classes:e,num_features:t,sparsity_ratio:r})})).json();if(!n.success)throw new Error(n.error||"Failed to initialize ternary model");return n.result}async quantizeWeights(){if(!this.isConnected)throw new Error("API not connected");const t=await(await fetch(`${this.baseUrl}/model/quantize_weights`,{method:"POST",headers:{"Content-Type":"application/json"}})).json();if(!t.success)throw new Error(t.error||"Failed to quantize weights");return t.result}async getTernaryStats(){if(!this.isConnected)throw new Error("API not connected");const t=await(await fetch(`${this.baseUrl}/model/ternary_stats`)).json();if(!t.success)throw new Error(t.error||"Failed to get ternary stats");return t.result}async toggleTernaryWeights(e){const t=e!==void 0?{use_ternary_weights:e}:{};return(await(await fetch(`${this.baseUrl}/model/toggle_ternary`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)})).json()).result}async initializeOptimizer(e="sgd",t=.01,r=.9,s=0){if(!this.isConnected)throw new Error("API not connected");const o=await(await fetch(`${this.baseUrl}/optimizer/init`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({optimizer_type:e,learning_rate:t,momentum:r,weight_decay:s})})).json();if(!o.success)throw new Error(o.error||"Failed to initialize optimizer");return o}async trainStepOptax(e,t,r){if(!this.isConnected)throw new Error("API not connected");const n=await(await fetch(`${this.baseUrl}/train_step_optax`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({batch_features:e,batch_labels:t,similarity_metric:r})})).json();if(!n.success)throw new Error(n.error||"Optax training step failed");return n.result}async getOptimizerStatus(){if(!this.isConnected)throw new Error("API not connected");const t=await(await fetch(`${this.baseUrl}/optimizer/status`,{method:"GET",headers:{"Content-Type":"application/json"}})).json();if(!t.success)throw new Error(t.error||"Failed to get optimizer status");return t.result}async resetOptimizer(){if(!this.isConnected)throw new Error("API not connected");const t=await(await fetch(`${this.baseUrl}/optimizer/reset`,{method:"POST",headers:{"Content-Type":"application/json"}})).json();if(!t.success)throw new Error(t.error||"Failed to reset optimizer");return t}}const l=new d;export{l as mnistApiService};
